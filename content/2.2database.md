# Using databases in Go

Go doesn't provide out of the box support for any database, but it provides an interface, which can be used by database library creators to keep
all the database libraries compatible with each other.  

We will use the sqlite database for this book.

#### Creating and configuring database

If you don't have sqlite installed, you can use the package manager of your OS to install sqlite3 database.

After installation use this DDL to create a table in our database

			[Tasks] $ sqlite3 tasks.db
			SQLite version 3.8.2 2013-12-06 14:53:30
			Enter ".help" for instructions
			Enter SQL statements terminated with a ";"
			sqlite> CREATE TABLE task (
				id integer primary key autoincrement,
				title varchar(100),
				content text,
				is_deleted char(1) default 'N',
				created_date timestamp,
				last_modified_at timestamp,
				finish_date timestamp
				);
		
Use the following insert statements to enter data in our table, so we'll begin reading data in our ShowAllTasks function which we wrote in the previous chapter

			INSERT INTO "task" VALUES(1,'Publish on github',
				'Publish the source of tasks and picsort on github',
				'N','2015-11-12 15:30:59','2015-11-21 14:19:22',
				'2015-11-17 17:02:18');
			
			INSERT INTO "task" VALUES(4,'gofmtall',
				'The idea is to run gofmt -w file.go on every 
			go file in the listing, *Edit turns out this is is difficult 
			to do in golang **Edit barely 3 line bash script :P '
			,'N','2015-11-12 16:58:31',
			'2015-11-14 10:42:14','2015-11-13 13:16:48');
			
			INSERT INTO "task" VALUES(7,'modifications to task',
				'1. add search function #Done
					2. a priority feature to task
					3. comments on tasks
					4. Due date
					5. remove dependency on httprouter #Done',
				'N','2015-11-13 04:23:27','2015-11-13 04:23:27',NULL);


#### Installing the sqlite driver for go

We'll use the go-sqlite3 driver created by [mattn](http://github.com/mattn). The reason being it implements the `database/sql` interface. 
Type this in your terminal:

			go get "github.com/mattn/go-sqlite3" 

#### Accessing database in go

We import the library as `import _ "github.com/mattn/go-sqlite3"` 

We are importing our driver anonymously, when we import any package default it gets imported as per its name, for instance when
we import `net/http` the exported variables/functions be available in the program as `http` for accessing functions and variables of the package, but since `go-sqlite3` is a database
package which uses the `database/sql` interface, we don't want all our database code to be specific to go-sqlite3, hence we give an empty operator as an alias
so we can use the functions without mentioning explicitly the package name & the none of exported fields are available. This is where the interoperability of databases comes into the picture.

Under the hood, the driver registers itself to the database/sql package.

### Note The '_' operator

The `_` operator has a unique role in go, it is used to denote an empty variable, used when we want to ignore data.  
`nums` is an array, while we loop through arrays using range it returns a (key,value) pair. here we ignore the key and print the value.			

			for _, value := range nums {
				fmt.Println(value)
			}
		
Also note that we can give a package alias instead of the underscore character should we want an alias for our package.

Every database has a connection mechanism, file for sqlite and IP address for MySQL/Postgres.
We define it as a global variable since we want it to be accessible in the package to keep our database access logic all in one package rather than sprinkling it around recklessly.

			var database   *sql.DB
			
			database, err = sql.Open("sqlite3", "./tasks.db")
			
			if err != nil {
					log.Fatal(err)
			} 

###### Note DB from godoc

			type DB struct {
				// contains filtered or unexported fields
			}

DB is a database handle representing a pool of zero or more underlying connections. It's safe for concurrent use by multiple goroutines.

The sql package creates and frees connections automatically; it also maintains a free pool of idle connections. If the database has a concept of per-connection state, such state can only be reliably observed within a transaction. 
We do not want this variable to be accessible from outside the package so it is unexported. Open may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call `Ping()`.
The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the Open function should be called just once. It is rarely necessary to close a DB. 

			err = db.Ping()
			if err != nil {
				//do something about it
			}

The sql.DB object shoudn't be opened and closed frequently, it should be closed only when we no longer need to access the database.

> Please refer to the documentation of `database/sql` for more details.

###### Note exported and unexported variables

In Go when a variable/function starts with a capital letter, it is public which means accessible from packages which import the package. It is good practice
to not keep any exported variables which are not required.

#### Querying the database

Statements that donâ€™t return rows should not use Query functions; they should use `Exec()`.

###### From the go documentation
	func (*DB) Exec
	
	func (db *DB) Exec(query string, args ...interface{}) (Result, error)
	
	Exec executes a query without returning any rows. The args are for any 
	placeholder parameters in the query. 

We use the `Query` method to query the database when we expect some result from the database.

		getTasksql = "select id, title, content, created_date from task
			where finish_date is null and is_deleted='N' order by created_date asc"
			
		rows, err := database.Query(getTasksql)
		
		if err != nil {
			log.Println(err)
		}
		
		defer rows.Close()
		for rows.Next() {
			err := rows.Scan(&TaskID, &TaskTitle, &TaskContent, &TaskCreated)
			TaskContent = strings.Replace(TaskContent, "\n", "<br>", -1)
			if err != nil {
				log.Println(err)
			}
			fmt.Println(TaskID, TaskTitle, TaskContent, TaskCreated)
		}

	
###### Note the defer keyword

We use defer inside a function call. 
			package main
			import (
				"fmt"
				"io/ioutil"
				"os"
			)
			
			func main() {
				file, err := os.Open('file.dat')
				if err != nil {
					fmt.Println("File doesn't exist or you don't have
					read permission")
				}
				
				defer file.Close()
				inputReader := bufio.NewReader(file)
				//do something about inputReader
			}

This guarantees us that the file will be closed before the main function returns, both in case of normal/abnormal termination. Take note of the
behaviour of defer before using it in your code. Becuase if it is misused it causes very difficult to find bugs.  

file `~/main/main.go` 

Find and fix the bug:

		package main
		import (
			_ "github.com/mattn/go-sqlite3" 
			"fmt"
		)
		
		var database   *sql.DB
		
		func init() {
			defer database.Close()
			database, err = sql.Open("sqlite3", "./tasks.db")
			if err != nil {
				fmt.Println(err)
			}
		}
		//intentional bug exists, fix it
		func main() {
			getTasksql = "select id, title, content, created_date from task
				where finish_date is null and is_deleted='N' order by created_date asc"
				
			rows, err := database.Query(getTasksql)
			if err != nil {
				fmt.Println(err)
			}
			defer rows.Close()
			for rows.Next() {
				err := rows.Scan(&TaskID, &TaskTitle, &TaskContent, &TaskCreated)
				TaskContent = strings.Replace(TaskContent, "\n", "<br>", -1)
				if err != nil {
					fmt.Println(err)
				}
				fmt.Println(TaskID, TaskTitle, TaskContent, TaskCreated)
			}
			err = rows.Err()
			if err != nil {
				log.Fatal(err)
			}
		}

Always defer `rows.Close()`, that way we free the database connection in the pool for so long as the `rows` contains the result set, the database
connection is in use and not available in the connection pool. When the `rows.Next()` function returns EOF (End of File), which means that it has reached
the end of records, it'll call `rows.Close()` for you, the `Close()` can be called multiple times without side effects.

###### Note the init function

The `init` function is the function which executes first before the file is imported or
executed. So package level initialization should be done in this function.


### Single-Row Queries 

If a query returns at most one row, you can use a shortcut:

			var taskDescription string
			err = db.QueryRow("select taskDescription from task where id = ?", 1).Scan(&taskDescription)
			
			if err != nil {
				log.Fatal(err)
			}
			
			fmt.Println(taskDescription)

Errors from the query are deferred until `Scan()` is called, and then are returned from that. You can also call QueryRow() on a prepared statement:

			stmt, err := db.Prepare("select taskDescription from task where id = ?", 1).Scan(&taskDescription)
			
			if err != nil {
				log.Fatal(err)
			}
			
			var taskDescription string
			err = stmt.QueryRow(1).Scan(&taskDescription)
			
			if err != nil {
				log.Fatal(err)
			}
			
			fmt.Println(taskDescription)

### Writing data into the database

We have seen how to fetch data from the database, now it is time to write data into the database, this is
done in two ways, by starting a transaction or without one. One should always start a transaction before inserting data so we don't get issues.
Don't take my word for it, I'd encourage you to find out the other method to write data into the database and see it for yourself.

Below lies an example of using transaction

file `db/db.go`

		//RestoreTask is used to restore tasks from the Trash
		func RestoreTask(id int) error {
			query := "update task set is_deleted='N',last_modified_at=datetime() where id=?"
			restoreSQL, err := database.Prepare(query)
			if err != nil {
				fmt.Println(err)
			}
			tx, err := database.Begin()
			if err != nil {
				fmt.Println(err)
			}
			_, err = tx.Stmt(restoreSQL).Exec(id)
			if err != nil {
				fmt.Println("doing rollback")
				tx.Rollback()
			} else {
				tx.Commit()
			}
			return err
		}
###### Note Prepare (from the go documentation)
Prepare creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed. 

###### Note Error handling

Go takes a different approach to exception handling than popular languages which use the try catch statements, although this results in one list in the
`if err != nil` land, but this makes the language small and simpler to handle exceptions because we don't need to remember those 1010101 different classes
the language/library takes care to identify the exception type for us and returns a error string, which we check for nil and then take some action on it. 

An excellent resource about Go and databases can be found at http://go-database-sql.org

##### The fault in our code:

Fixing the intentional bug in the above code:

	func init() {
			defer database.Close()
			database, err = sql.Open("sqlite3", "./tasks.db")
			if err != nil {
				fmt.Println(err)
			}
		}

The defer keyword calls the function when the calling function exits, in our case, `init` is a special function, so basically we are
opening the database and closing it immediately. Since init is the first function to be executed.

You might want to use call the database.Close() method from a wrapper in the views package through the main package. In this way, if the main function
which will be the controller of our application is terminated, we'll free up the database resource.
		

#### Links

- Previous section: [Basic Functionality](content/2.1functionality.md)
- Next section: 
