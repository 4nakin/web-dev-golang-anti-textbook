# Go Programming Basics

Go is a statically typed language and it is an easy to learn language. But that doesn't mean that programming in Go is really simple, becuase
some times it can cause some really subtle bugs which tend to be impossible to find, so we need to be careful in general while programming. Go also
has many restrictions like you can't have an unused variable. Go doesn't require you to add semi colons at the end of each line, but the compiler does
add semi colons at the end of each line, this is the reason braces are used for formatting. Go is a complied language, which means when we compile the code, it'll generate a 
statically linked binary. This means that after building your project (for your machine) you can take that binary and run it on machine with the same OS.
If your project involves the use of non Go files then you have to carry them along with the binary file since things don't scale well if the binary file has the
static files.

### Workspace

The standard way of writing Go code is to make a directory and assign it to the environment variable `$GOPATH`. In most unix systems it is done with
`export GOPATH=/usr/home/suraj/Go`. The idea is that all your Go code should reside in a directory tree so the code isn't lying around in random places.
There is another environment variable `$GOROOT` which holds the installation of Go language itself and is not to be confused with `$GOPATH`. 

My `$GOPATH` is ``/usr/home/suraj/Go``, it has the following structure
- pkg: The libraries which'll be imported in our code, there is a `.a` file created at the respective path.
- bin: The binary file of our project will be installed here on calling `Go install` in the project folder
- src: Will hold the actual code, if you have a github account, then you can create a folder tree inside like

Go
- src
	- github.com
		- thewhitetulip
			- wshare
			- picsort
	- golang.net
	- sourcegraph.com
- bin (binaries)
	- wshare 
	- picsort
- pkg

This makes it easy for organizing code because all my Go code lies in `$GOPATH/src/github.com/thewhitetulip`, and the rest of the code lies two levels up in 
`$GOPATH/src`. It also makes life easy for packages, as we'll see in the next sections, especially if you want to distribute your application or packages.

### Packages

Packages are a very integral part of the Go language since it was designed for building complex software for large teams. Unlike other languages one doesn't need to
do anything out of the ordinary for creating packages in Go, all you are required to do is create a folder of the name of the package and then use the statement
`package name` in each file which resides in the folder which you created. Please note that in each such folder/package there can be only one file with the main package 
declared, that is because when we build the Go code, the complier will get confused which file to build. Using packages is as easy as creating them. 

Don't use the MVC pattern just for the sake of using it, write a small web application entirely in the `main.go` file and later try to add a new feature to the application,
then you'll realize that having one file doesn't scale well, yes that is general knowledge but avoid doing things without understanding them well first.  

I didn't make the models & views initially, all handlers were moved into a `views.go` file located in a views folder, this became the views package. 

The database related methods went into a `db` package. 

The package name is `db`, but the way to name packages is to give their path from the `$GOPATH/src` directory, the reason being when the package is resolved 
by the Go compiler, then it first looks in the standard library and then starts looking for the **full** name in the `$GOPATH/src` folder. Hence it
is imperative to use the full name, else the code won't compile, which is useless if your application is distributed via the likes of Github.
 
Creating packages is useful in code reuse. This is the reason there needs to be a strong and active community across a language for it to be useful. 

Regarding the naming convention one might argue that we'll make the folders directly inside the `src` directory, in that way we can import packages
which have a single letter names like `database`, while this is possible, it is not recommended for multiple reasons, first, it might break
the flow of people who fork your project, for instance when you clone `github.com/thewhitetulip/Tasks/` it'll import all the required packages too, and 
if the packages were created just in the src directory, then it'll break the application, since if my db package isn't `github.com/thewhitetulip/Tasks/db` but just `db`
then the `go get` command will be unable to get the `db` package.

The downside of this is that when someone wants to fork your project, they have to rename all the package declarations.

### The main package

The main package is a special package in Go, its creation is optional, but if created, special care needs to be taken while building/running the application.

- With main package:
			
			[Tasks] $ Go build main/main.Go
			[Tasks] $ ./main/main

But if you Go to main folder and build and run then it won't run

			[Tasks/main] $ Go build main.Go
			[Tasks/main] $ ./main

This won't run because as per our instruction, the binary will expect all the static files and the rest of the packages in the current directory,
which is the directory called *main*, but all our other files are present one level up, so we have to ensure that we call the binary from one level up.

### Internal deployment

We'll code in our `$GOPATH/src/github.com` folder, but we also need to keep a deployment version on your machine. Since I use `Tasks` on a regular basis, I have made
a folder `~/Tasks` and here I keep the deployment version of Tasks, which contains the binary version and the static files.

### Running a server

Usually we run a server on some random 8000+ port, so it doesn't affect some other application which might be using ports, `godoc` uses the port `6060`.
While running a server, we have to bind the server to some IP address, we can use a public IP address, which would mean that anyone can visit your web app over
the Internet, or by using a private IP. But if you are on a private network, your machine is assigned an IP address, which can start with `192.0.0.0` or `10.0.0.0`. If
you run a server on that IP address, then your web server is accessible from over your LAN, so anyone in your LAN can use the web application.

So there are security implications while running your server, if you do

			log.Fatal(http.ListenAndServe(":8080", nil))

Then it'll bind the server to the IP address your machine is on the LAN. If you want your web application to be visible from only your machine then 

			log.Fatal(http.ListenAndServe("127.0.0.1:8080", nil))

###### Note: 127.0.0.1

`127.0.0.1` is generally called localhost, which is a special IP address which is given to every machine to refer to itself. it doesn't matter if you are 
connected to the network or not, your machine will always have this IP address, so if you are wanting privacy for your web application bind it to `127.0.0.1` because
no other machine in the world other than your own can see this IP address, if some other machine goes to `localhost` or `127.0.0.1` then it'll refer to itself.

Where as if you do want your web application to be accessible then bind it to `0.0.0.0.0:8080` or just `:8080`, when you give just the port number, the Go language
assumes the IP address the machine is on but **not** `127.0.0.1`. 
  

#### Links

- Previous section: [Tools](0.1tools.md)
- Next section: [Web Programming Basics](1.1servers.md)   