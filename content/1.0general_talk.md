#Workspace

The official way of programming in Go is to make a folder which'll be the golang universe on your machine and reference it as a environment 
variable called `$GOPATH`. 

Suppose for me `$GOPATH` is ``/usr/home/suraj/go``, it has the following structure
- pkg: The libraries which'll be imported in our code, there is a `.a` file created at the respective path.
- bin: The binary file of our project will be installed here on calling `go install` in the project folder
- src: Will hold the actual code, if you have a github account, then you can create a folder tree inside like

go
- src
	- github.com
		- thewhitetulip
			- wshare
			- picsort
	- golang.net
	- sourcegraph.com
- bin (binaries)
	- wshare 
	- picsort
- pkg

###Packages

Packages are a very integral part of the go language since it was designed for building complex software for large teams. Unlike other languages one doesn't need to
do anything out of the ordinary for creating packages in go, all you are required to do is create a folder of the name of the package and then use the statement
`package name` in each file which resides in the folder which you created. Please note that in each such folder/package there can be only one file with the main package 
declared, that is because when we build the go code, the complier will get confused which file to build.

Using packages is as easy as cerating them. I created a Tasks application which is a todo list manager. Initially I had everything in one single `main.go` file, but later
I felt the need to separate things in particular packages, yes, I hear you that we should use MVC and what not, but I thought I should experience the need of MVC and stuff 
thus I didn't follow that pattern intially, but then I realized that is was difficult to add a new feature to my application. Then I moved on the database related things to
the db package ` import github.com/thewhitetulip/Tasks/db`. The name is `db` but the way to name packages is to give their path from the `$GOPATH/src` directory, the reason being
when the package is resolved by the go compiler, then it first looks in the standard library and then starts looking for the **full** name in the `$GOPATH/src` folder. Hence it
is imperative to use the full name, else the code won't compile.
 
Now creating such packages is useful in code reuse, suppose someone creates some really useful package which lightens the burden of some aspect of web development, then
they'll package it as a package and we'll all imort it in our applications.

One might argue that we will not use the github naming convention and make the folders directly inside the `src` directory, in that way we can import packages
which have a single letter names like database, rather than the long names, while this is possible, it is not recommended for multiple reasons, first, it might break
the flow of people who fork your project, for instance when you clone `github.com/thewhitetulip/Tasks/` it'll import all the required packages too, and 
if the packages were created just in the src directory, then it'll break the application, since if my db package isn't `github.com/thewhitetulip/Tasks/db` but just `db`
then the `go get` command will be unable to get the `db` package because it won't know how to get it.

###Build

In each repo there will be one file in the `main` package, while there is no hard and fast rule to make a main package, but when done, the way to 
call the application is detailed below:

- With main package:
			
			[Tasks] $ go build main/main.go
			[Tasks] $ ./main/main

But if you go to main folder and build and run then it won't run

			[Tasks/main] $ go build main.go
			[Tasks/main] $ ./main

This won't run because as per our instruction, the binary will expect all the static files and the rest of the packages in the current directory,
which is the directory called *main*, but all our other files are present one level up, so we have to ensure that we call the binary from one level up.

######Note: difference between **go build** and **go install**
The `go build` command makes an executable of the current golang project, we can use the `go run main.go`. The `go run` command actually runs the `go build` command
but the executable is made inside the temporary directory `/tmp` in Linux

When we run `go install`, the binary of the existing project is moved to `$GOPATH/bin` directory, when we add this in the `$PATH` then we can use whichever utility we
made to call from anywhere on the commandline.

**Statically Linked binaries**
Go is a complied language, which means when we compile the code, it'll generate a binary file which we can run on the different OS, no virtualenvs to set up
just one platform specific binary file which we run. There is literally no dependancy when you have the binary file, it is just like plug and play.

#### Links

- Previous section: [Tools](0.1tools.md)
- Next section: [Sneak Peak](1.1servers.md)   