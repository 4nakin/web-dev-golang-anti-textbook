#Authentication

Authentication is used to verify if the users have access to that particular part of your web application. For understanding how to implement authentication
we need to understand what happens behind the scenes of a browser. Suppose we run a bank webapplication. We want only our legitimate users to access our
webapplication. We set up a login page and provide our users with their username and password which they can use to validate their claim to our webapp.

When we submit the login form, the browser takes our username, password and sends a POST request to the webserver, which again responds with a HTTP redirect response
and we are returned to our bank dashboard.

The HTTP protocol is stateless, which means every request is unique. There is no way for identifying automatically if a request is related to another request.
This brings about the problem of authentication, how then can we validate if the users have access to our webapp?

We can send the username along with each HTTP request, either in the URL via a GET request or in the POST request. But this is inefficient since for each
request, the webserver would need to hit the database to validate the username, also this would mean weak security since if I know your username, I can impersonate you
pretty easily and the webserver is helpless to identify this impersonation.

To solve this problems Sessions were invented, sessions need to use cookies on the browser to function. The basic idea is that the server generates a sessionID
and stores it in a cookie. With subsequent requests, the browser will send the sessionID along with the request, the webserver will then come to know from that sessionID
if the request is a fake one or not. Also we get to know who the user is from that.

###Cookies
Cookies, as we saw in a previous chapter can be used to store a key,value pair. We used a cookie to store the CSRF token, the cookie had the name as CSRF
and value as the token.

Please don't confuse sessions with cookies, because sessions aren't a key,value pair. Sessions are a way of working with cookies on the server side. There is a gap of
the entire Internet between sessions and cookies.

Cookies are stored in our browsers, for security reasons we need to enable the "isHTTPOnly" field of our cookies, so only our webapplication can read the cookie.
Otherwise anyone javascript application can easily read our cookie defeating its purpose, we might as well not keep an authentication mechanism for our webapp. 

From the go documentation
		type Cookie struct {
			Name  string
			Value string
		
			Path       string    // optional
			Domain     string    // optional
			Expires    time.Time // optional
			RawExpires string    // for reading cookies only
		
			// MaxAge=0 means no 'Max-Age' attribute specified.
			// MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'
			// MaxAge>0 means Max-Age attribute present and given in seconds
			MaxAge   int
			Secure   bool
			HttpOnly bool
			Raw      string
			Unparsed []string // Raw text of unparsed attribute-value pairs
		}

The `domain` of our cookie enables a restricted access to our cookie. A visitor goes to our fictional bank website, sbank.com
and enters a username and password, a cookie is stored in the browser which only the sbank.com domain can access since we are security
aware and we have set the HttpOnly field to true while setting the cookie. This means some malicious website which is set up by an attacker
to intentionally target our bank isn't able to access the cookie using javascript.

One has to remember that cookie is nothing but a file stored in a user's browser, if can be accessed over HTTP by our webserver,
a client browser does allow access to it through browser settings or custom javascript. The browser, after all is a platform, and 
we have APIs to that platform. 

###Sessions

A session is a series of actions performed between you and the webapp you are acting, enabled by the browser and the Internet you are using.
While generating a new session, we need to check if a sessions is already active, if so we return the same session ID rather than create a new one,
if not, we generate a new session ID. Session IDs need to be sufficiently random. Of course we can't generate something totally random, but we have to ensure
to generate something that nobody else can replicate, unless they have access to our private key which we use to generate our random number.

login/logout
reset password
sessions
token based authentication
store session in database not memory