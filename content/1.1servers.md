#Sneak Peak into the future

Web servers are programs which respond to requests, the format of the request is the HTTP protocol. The golang has a library which helps to save 
the programmer a lot of time and build applications quickly on top of http. A request is called HTTP Request and its corresponding response is called
HTTP Response. Since we don't have to bother about actually implementing the HTTP protocol, all we have to do is send the appropriate HTTP Response for
each HTTP request pattern, along with a HTTP Request, we have a URL and the request type (GET, PUT, POST, DELETE)

The HTTP protocol initially was built only for transferring plain text, but later it started supporting multimedia content too. When we type www.github.com
on our browser's address bar, then it by default adds `https://` or `http://` and a trailing forward slash, so our request becomes HTTP GET / github.com. Our
browser will locate the IP address of the website github.com and sent in a HTTP GET / request, the server of github.com will take the request, go to the view 
handler handling the URL pattern, typically `/` is the default pattern which shows the login page or some non critical stuff until you login.

Until AJAX was invented servers served static html pages, now it is possible to do async communication between the client and the server, which, in plain 
English means that you can change the data on a page without refreshing the page. Which is cool and is expected of any modern website running in the 21'st century.
But of course as with everything in life, you first have to walk before you run, so first static html then AJAX enabled html.

There are two major HTTP methods, `GET` and `POST`, GET is used to basically get the document stored for a URL, suppose GET / will get the home page for 
that website, but when we have to send data to the server, suppose we fill a registration form, then the page sends a POST request to some URL which then
reads the data of the form and does something appropriate with it.

##Example

Suppose we run a blog, the smallest component is a post, a post has tags, it is written by some author, at some time and has some primary key
to uniquely identify it in our database and it has a slug which means the URL.

Earlier URLs used to be ugly, but now they are beautiful, like our fictional blog has this post, `surajblog.com/posts/welcome-the-new-year`,
the slug is the `welcome-the-new-year`.

When the server gets a HTTP GET request of `/posts/welcome-the-new-year`, it'll search for URL handlers starting with the list of URL 
handlers we have given, then it'll find the closest match, in our case it'll be `/post/`, then it'll call the handler of this URL. The library will
go from the top to bottom of the `HandleFunc` listing, hence our `/` root URL should be at the very bottom of our list.

        http.HandleFunc("/post/", ShowPostBySlug)
        http.HandleFunc("/", ShowAllPosts)

What this handler will do is that it'll go to the database, fetch the (id, title, content, time) from the database for that particular post
then it'll read a `template` and populate data into the template, which is ultimately the HTML document which is sent back to our browser.

##What is a template?

While building web applications in any programming language, we have a templating language associated with it, as the name suggests, is a template
a model, giving you the taste of a real life template being used in the webapp which we'll create eventually, is part of the template pasted below.

It first checks the `Tasks` is empty, and if it is empty then it'll show No Tasks here, otherwise it'll loop through the object and how all the Tasks
which are in the object.

        <div class="timeline">
                {{ if .Tasks}} {{range .Tasks}}
                <div class="note">
                     <p class="noteHeading">{{.Title}}</p>
                     <hr>
                     <p class="noteContent">{{.Content}}</p>
                </div>
                {{end}} {{else}}
                    <div class="note">
                        <p class="noteHeading">No Tasks here, add new 
                        <a href="#add">here</a></p>
                    </div>
                {{end}}
        </div>


#####Note:
It is a good UX practice to provide a way to add Tasks while showing the *No Tasks here* message. Because just showing "No notes exist" is an unfruitful message
for the user, it'd be more useful to provide a way to do something on the page. You might have come across HTTP404 pages which show some navigation link, because 
that is good UX, the user doesn't have to go back to the home page to be productive again.


So writing a web application essentially means, we have to decide upon the URLs, the structure of the database and write functions in golang to handle 
each supported pattern of URL, then write templates to populate each URL, the handlers which we write populate data in the templates, a method generally
known as **rendering**.

###Not abusing templates

Templates support a lot of things like in template variables, but one has to make sure that there is no business logic inside the template and we
separate the business logic from the presentation. Web apps which follow these are easily maintainable since the change in business logic doesn't mean
that we have to change everything, but with one app divided into modules, this triggers a changed in that particular part of the module.

Suppose we write a todo list manager which supports multiple users, so we have to ensure that we show tasks of that particular user rather than 
sending all the tasks to the template and filtering there tasks which are of that user on every page. A better approach will surely be to pass the tasks of only that
user while rendering the template, so in the future if we want to show tasks of some user and his friend, then we won't have to change the template, we'll
just modify the function which populates the Tasks object.

Below is such method which is used to handle the backend functionality of our *EditTask* URL which is `/edit/<id>`
located at `~/db/db.go`

        func GetTaskByID(id int) types.Context {
            var tasks []types.Task
            var task types.Task
            var TaskID int
            var TaskTitle string
            var TaskContent string
            getTasksql := "select id, title, content from task where id=?"
        
            rows, err := database.Query(getTasksql, id)
            if err != nil {
                    fmt.Println(err)
            }
            defer rows.Close()
            if rows.Next() {
                err := rows.Scan(&TaskID, &TaskTitle, &TaskContent)
                if err != nil {
                    fmt.Println(err)
                }
                task = types.Task{Id: TaskID, Title: TaskTitle, Content: TaskContent}
            }
            tasks = append(tasks, task)
            context := types.Context{Tasks: tasks, Navigation: "edit"}
            return context
        }


If you notice, we aren't rendering the template here, because this is a database package who's job is to return the appropriate data to the view,
which will render the template from the data sent by the database function.
file path: `~/views/views.go`

        //EditTaskFunc is used to edit tasks, handles "/edit/" URL
        func EditTaskFunc(w http.ResponseWriter, r *http.Request) {
            if r.Method == "GET" {
                id, err := strconv.Atoi(r.URL.Path[len("/edit/"):])
                if err != nil {
                    fmt.Println(err)
                } else {
                    task := db.GetTaskByID(id)
                    editTemplate.Execute(w, task)
                }
            } else {
                message = "Method not allowed"
                http.Redirect(w, r, "/", http.StatusFound)
            }
        }

Thus we can split an application into views, database, templates and the main file. This is the standard way of doing things in this world, not because it is
the status quo, but because it is easier to maintain the webapplications that way and since maintainability is the holy grail for software
you are recommended to follow this.

The main file will get the URL pattern and match with the handlers which are present in views, the views get the items from the database and render
the necessary template.

#Serving static files

Static files play a major role in our web application, they are all the CSS/JS/Images which we load into our html pages we serve them over the URL patten
`/static/`, the way this is implemented is that whenever a request like `/static/<filepath>`, we go to the public directory of our application and then 
look for the path which we got, if we get a file of that path then we serve the file, othewise it automatically sends a 404 error.

The project structure should include a `public` which'll contain all your static files including templates. The internal structure can be anything
you like for you are going to reference the path names in your code.

        public
        |   |-- static
        |   |   |-- css
        |   |   |   `-- styles.css
                        ..and more
        |   |   `-- js
        |   |       |-- bootstrap.min.js
        |   |       .... and more
        |   `-- templates
        |       |-- completed.html
                ...and more        


#####Note:
The above output is of the `tree` program. `sudo apt-get install tree` to install using aptitude

#### Links

- Previous section: [General Talk](1.0general_talk.md) 
- Next section: [Basics webapp](2.0implementbasics.md)